# RocketRecorder
Using a Raspberry Pi with a Pi Camera to record high-powered rocketry flights. Can be applied to anything else. Basically just a set of scripts that allows local video recording without having to type commands in the terminal of the pi.

Copied from originial Reddit post:

Hello All!
The purpose of the post is to share my project, get some insight, and most importantly assistance with troubleshooting. Any and all suggestions, recommendations, comments, and criticism is appreciated. This is the first time I have ever done a project of this nature. Sorry in advance for the book I wrote below LOL. It is also the first reddit post I have done for something like this, so I am going to try and detail as much as possible to get the full scope. If I miss something, or phrase something weird, let me know and I will fix it for better clarification! If this project sounds familiar to something you have done or seen, please let me know. I have done some searching and it seems like I am the first to try and do this specific project.
LINK TO CODE:  
Project Background: Let me just get right into it. I am creating a video recorder in hopes to use it on a high-powered rocketry flight. COTS camera recorder options are off the table, as I do not want essentially a brick protruding off the side of the rocket. I chose to use raspberry pi, as I want digital video rather than analog. I chose not to purchase digital FPV recording equipment, as I already obtain the necessary materials to create it with a Pi Zero and Pi Camera 3 Module (also a college kid on a budget). I am not using a microphone with this setup, so I will be using the .h264 video format. 
Project Limitations: Since it will be used to record video of a rocket flight, I cannot rely on using WiFi to save the video. Everything will be saved locally on the micro SD. Since the Pi will be inside of a rocket, I cannot attach any screens, usb inputs, etc. I cannot plug the pi in and start a libcamera process to record and then disconnect power to stop the recording. One, that would not be very efficient. Two, I risk corrupting the video file if the process is not stopped properly.
Workarounds and Physical Setup: I have opted to use a handful of sensory indicators to help me identify which step the recorder is in. A buzzer to beep when ready to record, when recording starts, and when recording stops. LEDs to illuminate and flash for the same steps(an initializing LED and recording LED). I have included a very crude wiring diagram(plz don't judge) that shows how everything is connected and a photo of the setup on a breadboard. The pi is loaded with the latest full OS and I am using the gpiozero library to operate the components. 
Description of the Code Functionality(CODE IS LOCATED IN COMMENTS): This is where things have become hairy for me. I am by no means a programming wiz. I understand some of the lingo and syntax for the code, but my intuition is quite limited. I have primarily utilized AI to help me write the scripts for this project, but it seems I have found its limits. I will do my best to describe what the code is designed to do. I am currently using two python scripts, two shell scripts, and a cron scheduler. All scripts are set up with print functions for debugging and creates log files of each script. The log files will allow me to go back and check what happened if an undesired outcome occurs and I am not connected to a display with a terminal open. 
     -The cron scheduler (Crontab.XP5Jhz/crontab) simply just starts the check_pin19.py  python script on boot up of the pi. I currently have it disabled until the code is fully functional.
      -The first python script (check_pin19.py) is designed to check the switch from the wiring diagram. This switch would be activated on the launch pad with the rest of the onboard electronics. The pi would be powered on before getting to the launchpad. The script is simply running a check of pin 19, where the switch is connected, and if it is on at any point then to run the next script and end itself. It flashes the LEDs and beeps the buzzer to indicate that the switch turn on is detected. It has to end itself before running the next script to free up the gpio, as I am utilizing the wired components in both scripts. Once the switch is turned on, turning it off does nothing. It is now in a standby mode waiting to start the recording.
      -The next script (gpio_control.py) is the meat of the program. It is designed to check if recording is happening or not, and to do the opposite of what is detected when there is user input. The user input is holding the button down for 3 seconds to ensure recording is intended and to prevent accidental activation.  Once the button has been held for 3 seconds, the recording will begin. It starts the recording by calling to the start recording shell script The LEDs will indicate this process happening where the recording LED goes solid, and the buzzer sounds. To stop the recording, the user would again hold the button for 3 seconds and the recording LED would turn off. This calls to the stop recording shell script.
     -The shell script that starts the recording (start_recording.sh) first creates a .h264 file and gives it a unique number. It also checks the folder for previous recordings and increments them by 1 (e.g. video_0001, video_0002). It then starts a libcamera-vid process to start the recording and creates a control file that stores the libcamera PID. It continuously checks for the presence of the stop_recording fiIe(not to be confused directly with the stop_recording.sh shell script). If the file is detected, it executes a kill command of the PID that was stored, ending the recording.
     -The shell script that stops the recording (stop_recording.sh) reads the PID from the control file that was stored. If it locates a PID within the control file, it creates the stop_recording file, activating the kill command in the previous shell script.
Actual Performance and Current Issues: The check_pin19 script works with no issue. It flashes the LEDs, beeps the buzzer, and starts the gpio_control script. Starting the recording comes with no issue as well. When the button is held down (the intializing LED illuminates) and held for three seconds (Initializing LED begins blinking and buzzer beeps) the recording starts(recording LED goes solid). 
     The issue comes when trying to stop the recording, which is arguably the most important part of the program. The whole point of this was to softly stop the recording rather than having to directly remove power from the device. I again hold the button down for three seconds(LEDs respond accordingly) and it stops the recording, but immediately starts another recording again. This is not the end of the world, but I would like it to stop any recording processes before I power it down.  Inside of the gpio_control.py, the button_pressed_time is a variable stored to determine if the button is held for three seconds. I believe that it was immediately starting the recording back up because the variable was not reset, meaning the button_pressed_time >= hold_time still. So it gets stuck in a loop of stopping and immediately starting again. I thought it was a simple fix by setting the variable =None after it had started the recording process, but that brought me a different issue. When holding the button for three seconds(init LED starts blinking) and I release, the initializing LED does not stop blinking, the recording LED does not turn on, and recording does not start. It gets stuck flashing the initializing LED for some reason. AI tried to fix it by defining a new function called button_held() and tried to use it to go to the stop_recording() function, and it has me all confused now. Currently, I have the button_pressed_time = None in the button_released() function, but I do not know where to exactly put it to solve the issue. Please let me know if you think my issue is related to reseting this variable value. 
If you made it this far, you are a real trooper. Thank you for taking the time to read this and I hope I sparked some ideas for you.  
